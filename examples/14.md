BFS, DFS

너비우선탐색 BFS

=> 같은 깊이에 해당하는 정점부터 탐색
=> 큐를 사용해서 구현을 한다.
=> 정점의 수 + 간선의 수만큼 시간이 걸린다.

A
D, C, B
E, F, F
G

이런 그래프가 있다고 치면 큐에 아래와 같은 순서로 채운다

1. [A]
2. A를 빼내고 A에서 1칸 이동해서 접근할 수 있는 모든 정점을 넣는다: [B, C, D]
3. B를 빼내고 B에서 1칸 이동해서 접근할 수 있는 모든 정점을 넣는다: [C, D, F] (A,C는 있거나 이미 방문했으니 넣지않는다)
4. C를 빼내고 C에서 1칸 이동해서 접근할 수 있는 모든 정점을 넣는다: [D, F] (B,F는 있거나 이미 방문했으니 넣지않는다)

5. D를 빼내고 D에서 1칸 이동해서 접근할 수 있는 모든 정점을 넣는다: [F, E] (A는 이미 방문했으니 넣지않는다)
6. F를 빼내고 F에서 1칸 이동해서 접근할 수 있는 모든 정점을 넣는다: [E, G] (B,C는 이미 방문했으니 넣지않는다)
7. E를 빼내고 E에서 1칸 이동해서 접근할 수 있는 모든 정점을 넣는다: [G]
8. G를 빼내고 G에서 1칸 이동해서 접근할 수 있는 모든 정점을 넣는다: []

큐가 모두 비었기 때문에 탐색을 종료한다.

즉 반복 조건: 큐에 무언가가 있는 동안은 계속 반복한다.
=> 이미 방문한 정점은 방문 기록을 어딘가에는 남겨야 한다.

깊이우선탐색 DFS

=> 최대한 깊은 정점부터 탐색한다.

스택을 사용해서 구현한다.
시작 정점에서 깊은 것부터 찾는다
정점의 수 + 간선의 수만큼의 시간이 걸린다.

위의 동일한 그래프를 가지고 설명해보면

1. 스택에 A를 푸시한다 [A]
2. A바로 다음의 정점 중 임의의 정점 B를 추가한다 [A,B]
3. B바로 다음의 정점 중 방문안한 정점 F를 추가한다 [A,B,F]
4. F바로 다음의 정점 중 방문안한 임의의 정점 C를 추가 [A,B,F,C]
5. C에서는 더 이상 갈 수 있는 정점이 없기 때문에 pop 하고, F로 돌아와서 미방문한 정점 G를 추가 [A,B,F,G]
6. G에서는 더 이상 갈 수 있는 정점 역시 없기 때문에 pop하고, F도 마찬가지, B도 마찬가지로 빠진다 [A]
7. 미방문한 정점 D를 추가한다. [A,D]
8. D에서 미방문한 정점 E를 추가한다. [A,D,E]
9. E에서 더 이상 갈 수 있는 곳 없어 pop한다. [A,D]
10. D에서 더 이상 갈 수 있는 곳 없어 pop한다. [A]
11. A에서 더 이상 갈 수 있는 곳 없어 pop한다. []

반복 조건: 스택에 무언가 있는 동안은 계속 반복을 한다. 스택의 모든 요소가 없어지면은 반복을 종료한다.
이미 방문했던 정점은, 어딘가에 방문 표시를 해줘야 한다.
