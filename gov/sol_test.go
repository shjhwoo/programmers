package main_test

import (
	"testing"

	"gotest.tools/v3/assert"
)

type TestCase struct {
	x      int
	y      int
	n      int
	expect int
}

/*
문제 설명
자연수 x를 y로 변환하려고 합니다. 사용할 수 있는 연산은 다음과 같습니다.

x에 n을 더합니다
x에 2를 곱합니다.
x에 3을 곱합니다.
자연수 x, y, n이 매개변수로 주어질 때, x를 y로 변환하기 위해 필요한 최소 연산 횟수를 return하도록 solution 함수를 완성해주세요. 이때 x를 y로 만들 수 없다면 -1을 return 해주세요.
*/
func TestSolution(t *testing.T) {
	var tests = []TestCase{
		{
			x:      10,
			y:      40,
			n:      5,
			expect: 2,
		},
		{
			x:      10,
			y:      40,
			n:      30,
			expect: 1,
		},
		{
			x:      2,
			y:      5,
			n:      4,
			expect: -1,
		},
	}

	for _, test := range tests {
		ans := solution(test.x, test.y, test.n)
		t.Log(ans, "계산값")
		assert.DeepEqual(t, test.expect, ans)
	}
}

func solution(x int, y int, n int) int {
	/*
			10 * 2 = 20 --- 1번
			20 * 2 = 40 --- 2번

			----------------------
			10 + 30 = 40 --- 1번
			----------------------

			2에 * 2 곱 => 4가 된다. 4에서 5를 만들려면 1을 더해야하는데 안됨
			2에 * 3 곱 => 6이 된다. 뺄셈은 금지이므로 안됨
			2에 4를 더함 => 마찬가지로 안됨.
			=> 단 한번의 연산으로도 안됨..


			당장 생각나는 풀이로는.
			1. 무조건 2만 계속 거듭해 곱한다.
			2. 무조건 3만 계속 거듭해 곱한다.
			3. 무조건 n만 계속 거듭해서 더한다.
			4. * 2 * 3
			5. * 2 * 3 + n
			6. + n) * 2
			7. + n) * 2 * 2 ..... 계속 거듭해 곱한다
			8. + n) * 3
			9. + n) * 3 * 3 ..... 계속 거듭해 곱한다
			8. + n) * 2 * 3


			각 방법을 하나하나 일일이 체크하기에는 너무 많다.
			약수를 활용하면 좋지않을까..

			10, 40, 5 의 경우:

			40은 10으로 나누어떨어진다. => 10 * 2 * 2
			사실상 5를 더하여 40을 만들기에는 불리한게 5는 10의 약수니까.
			10+ 5) * 2 + 10 => 이렇게 구한다고 하면, 3번의 연산을 하게됨.

			만들 수 없는 경우는 왜 못만드는지가 힌트가 될 수 있을 거 같다.
			일단, 5는 2의 배수가 아니다.
			그러면 5를 2로 나눴을 때 몫은 2니까 일단 2는 곱해서 4를 만들고, 나머지 1은 덧셈연산으로
			보충하면 되는데, 더할 수 있는 수는 4이다. 그러므로 만들 수 없다.

			또는 x , y가 같은 경우에도 만들 수 없음.

			----------------

			y는 x로 나누어떨어지는가?
			=> 나머지가 n보다 작다면 -1 ... (3, 10, 5)
			=> 나누어떨어지는 경우 몫을 확인해본다.
				몫이 1이면 -1
				몫이 2, 3이면 1
			=> 나누어떻어지지 않는 경우에는 x에 n을 1번 더하고 그걸로 y를 나눠본다. (2, 23, 7)
				몫이 1이면 1
					이때 나머지가 2,3의 배수면,, 1 + (나머지 / 2또는 3으로 나눈몫)
				몫이 2, 3이면 2

		-----------------------
		다른 아이디어!
		Y에서 거꾸로 X를 만들어가는거다.
		0을

		(((x + n) * 2)+ n)) * 3 = 6x + 9n = y
		2 * x + n  = y

		x = (y - _n) / (2, 3 또는 6의 배수)

		일단  x에는 2또는 3, 6의 배수가 곱해질 수 있다.
		n은 어떤 배수는 붙을 수 있음..
		만약에 분자를 분모로 딱 맞게 나눠떨어지게 할 수 없다면 그건 -1을 줘야 함!!

		분자도 보니깐 n으로 나눈 나머지일수도 있겠다. 항상 그런건 아니겠지만.

		즉 분모 + _ 의 최소를 구해야한다.
		당연히 둘 다 최소여야 최소를 구할 수 있겠지만..

		분모가 가질 수 있는 최소값의 종류: 2, 3
		분자가 가질 수 있는 최소 _ : 1 부터 시작하자!!

		그렇게 조금씩 늘려나가면서 값을 찾았을 때 멈추고 값을 리턴하면 될 거 같다.
	*/

	//특이 케이스 처리하기
	if x+n == y || x*2 == y || x*3 == y {
		return 1
	}

	var nAddTime int = 1
	var mulTime int = 1
	var answer = nAddTime + mulTime //기본 베이스.

	/*
		x * (2, 3, 6의 배수) = y - (n을 더하는 횟수) * n
		위 식을 만족하는 어떤수 + n을 더하는 횟수 최소값을 찾아야함.

		그래프의 기울기를 사용.

	*/

	if (y-n*mulTime)%2 != 0 || (y-n*mulTime)%3 != 0 || (y-n*mulTime)%6 != 0 {
		return -1 //나누어 떨어지지 않는 경우
	}

	for {
		mulOfX := y - n*mulTime
		if mulOfX%6 > 0 {
			break
		}

	}

	return answer
}
